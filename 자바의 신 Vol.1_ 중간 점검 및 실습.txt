1. 
참조 자료형은 Java에서 기본적으로 제공되는 타입이 아닌, 커스텀된 자료 타입이다.
초기화는  new 를 활용, 기본값이 정해져있지 않다.
이에 반해 기본형은 자바에서 기본으로 제공되는 타입이며, byte, short, int, long, char, float, double, boolean 등이 있다.
기본값이 존재하며, 초기화는 대입 연산자를 활용한다.
>> 참조 자료형(Reference type)	
- 기본 자료형 외의 모든 타입은 참조 자료형
- 개발자가 클래스로 직접 생성 가능
- String 클래스만 + 연산 사용 가능하고, 나머지는 모두 불가능
- Pass by Reference: 매개변수로 전달할 때 참조 객체(주소값)를 전달하기 때문에 값 변경 가능

기본 자료형(Primitive type)
- byte, short, int, long, float, double, char, boolean 타입
- 이 외에는 개발자가 직접 생성 불가능
- 모든 사칙 연산(+, -, *, /, % 등) 가능
- Pass by Value: 매개변수로 전달할때 값만 전달하기 때문에 값 변경 불가능

2. 
byte - 정수형 1바이트
short - int보다 작은 범위의 숫자를 나타내기 위한 용도, 
> 정수형 2바이트
int - 21억까지,
> 정수형 4바이트
long - int보다 큰 범위의 숫자를 나타내기 위함
> 정수형 8바이트
char - 문자열 하나를 나타내는데 사용/ 16-bit Unicode 
> 정수형 2바이트
float - 실수를 나타내는 용도,
> 소수형 4바이트
double - 
> 정수형 8바이트
boolean - 참과 거짓을 나타내기 위한 용도

3. 서로 다른 데이터형을 활용할 필요가 있기 떄문에 해야한다.
더 큰 범위에서 작은 범위로 캐스팅할 떄 활용하는 명시적캐스팅이 있고,
반대의 경우는 메서드를 활용하기도 한다.
>> byte에서 int로 형 변환을 할 때에는 작은 범위에서 큰 범위로 변환하는 것이기 때문에 자동으로 되지만,
int에서 byte로 형 변환을 할 때에는 큰 범위에서 작은 범위로 변환하는 것이기 때문에 예상하지 못한 값으로 변형이 될 수도 있다. 이것을 개발자가 감안한다는 가정 하에 형 변환한다는 것을 직접 명시해 주어야만 한다.

4. 로직의 분기를 위해서 사용한다.
if-else는  if문 외에는 모두 else로 가며,
if- else if는 if외에 모두가 아닌, else if로 정해진 케이스에 else if로 가는 차이가 있다

5. 특정값의 여러가지 상태에 따른 분기를 효과적으로 하거나 값에 상관없이 기본적인 값이나 메서드를 실행할 필요가 있을 때 활용한다.

6.
for
반복문을 사용해야할 떄 사용한다.
int result = 0;
for(int i =1; i < 11; i++){
	result += i;
}
do-while
int result = 0;
int num = 2;
do{
	result += 1;
}
while(num < 11){
	reulst += num;
	num ++;
}

>>
do-while
   int sum = 0, n = 1;
        do {
            sum += n;
            n++;
        } while (n <= 10);
        System.out.println(sum);
while
int reulst = 0;
int num = 1;
while(num < 11){
	reulst += num;
}

7.
String[] arr = new String[2]{"3.6", "3"};
for(String str : arr){
	System.out.println(str);
}

8.
특정 클래 객체를 생성하는 것에 사용.
기본생성자인데, 어떠한 생성자도 따로 만들어주지 않았을 때는 기본으로 만들어주지만, 만약 다른 생성자를 만들었다면 해당 사항 없다.

9.
특정 메서드를 재활용하여 재정의하는 것.
>> Overloading은 메소드의 이름은 같은데, 매개변수의 타입 및 개수가 다른 메소드를 1개 이상 선언하는 것이다.
public void setData(int a, int b){
	//code
}

10.
파일의 최상단
모두 소문자를 활용
java 예약어 금지
java, javax 단어 금지
.으로 구분

11.
패키지 아래
>> 패키지 아래 클래스 위
전역으로 import 하는 것. 프로그램이 실행된 순간부터 끝날 떄까지 유지.
>> import static은 클래스 내에 static으로 선언한 변수나 메소드에 접근하려고 할 때, 그 변수나 메소드 이름만 코드에 작성하려고 할 때 사용한다.

12. 
현실 세계의 사물을 상태와 행위로 나타내는 것. 여기서 상태란 해당 사물의 속성을 변수나 필드 드응로 나타내는 것을 의미하며, 행위는 메서드를 의미

13.
구현해야하는 메서드가 있다고 치면, 이걸 외부에 알리지 않고, 어떠한 메서드만 존재하는지 알 수 있게 (정보 은닉)
해주는 필요가 있을 떄 인터페이스를 사용
이 떄, 인터페이스는 직접 구현 안됨. 하지만 경우에 따라서 구현해야하는 경우에 추상 클래스를 활용.
2개 다 실제로 바디가 없는 것들은 구현이 구현체 등에서 되어야함. 
인터페이스는 implements 활용, abstract는 extends 활용
일반 클래스는 일상의 사물을 상태와 행동을 활용하여 나타낸 것. 각각 필드와 메서드로 나타내어줌.
enum은 열거형 성격을 가지는 값들을 모듈화해놓은 클래스. 대문자와 _ 를 활용하여 네이밍이 일반적. 

14. 
특정 객체가 어떤 클래스의 인스턴스인지 명확하게 분류할 떄 활용
>> 해당 객체의 클래스 타입을 확인하려고 할 때 사용한다.

15. 
메서드등을 활용할 수 있음. Object 클래스의 toString이 대표적


16.
더이상 수정할 수 없음을 의미
매개변수는 넘겨주는 메서드에서 초기화와 값 할당이 모두 완료된 상태로 넘어와서 이후에 수정이 안된다는 것을 의미

17.
클래스는 상속의 대상이 안됨.

18.
전역에서 활용 가능한  변수가 된다는 것을 의미
static 변수가 있다면 해당 클래스는 static으로 선언해야 함.
프로그램으 시작부터 존재해서 끝날 떄까지 존재
>> 클래스 변수라고 함
클래스 타입이 같은 객체들은 해당 변수를 공유

19.
전역에서 활용 가능한  메서드가 된다는 것을 의미
static 변수가 있다면 해당 클래스는 static으로 선언해야 함.
프로그램으 시작부터 존재해서 끝날 떄까지 존재

20.
실행하는 코드가 반드시 성공한다는 보장이 없어 예외처리를 해야할 때 사용하는 구문.
try
- 일단 시도해보는 코드
catch
- 에러가 나면 try의 아래 코드 무시하고 catch로 이동.
주로 에러 분석을 위한 로그 등을 남김
finally
try-catch 여부에 상관없이 실행되는 곳.